function [xtraj, ttraj, terminate_cond] = test_trajectory_dcapt(var, start, stop, map,  vis)
% TEST_TRAJECTORY simulates the robot from START to STOP following a PATH
% that's been planned for MAP.
% start - a 3d vector or a cell contains multiple 3d vectors
% stop  - a 3d vector or a cell contains multiple 3d vectors
% map   - map generated by your load_map
% path  - n x 3 matrix path planned by your dijkstra algorithm
% vis   - true for displaying visualization
% vis = false;
%Controller and trajectory generator handles
controlhandle = @controller_dcapt;
trajhandle    = @dcaptTrajGenerator;
hdist = var.h;
% Get nquad
nquad = length(start);

% Make column vector
for qn = 1:nquad
    start{qn} = start{qn}';
    stop{qn} = stop{qn};
end

% Quadrotor model
params = nanoplus();

%% **************************** FIGURES *****************************
% Environment figure
if nargin < 5
    vis = true;
end

fprintf('Initializing figures...\n')
if vis
    h_fig = figure('Name', 'Environment');
else
    h_fig = figure('Name', 'Environment', 'Visible', 'Off');
end

h_3d = gca;
drawnow;
xlabel('x [m]'); ylabel('y [m]'); zlabel('z [m]')
quadcolors = lines(nquad);
set(gcf,'Renderer','OpenGL')


%% Trying Animation of Blocks

        xlabel('x'); ylabel('y'); zlabel('z'); 
        axis([0 var.bound(1) 0 var.bound(2) 0 var.bound(3)])
        grid on
        hold on
%% *********************** INITIAL CONDITIONS ***********************
fprintf('Setting initial conditions...\n')
% Maximum time that the quadrotor is allowed to fly
time_tol = round(var.tf);          % maximum simulation time
starttime = 0;          % start of simulation in seconds
tstep     = 0.1;       % this determines the time step at which the solution is given
cstep     = 0.5;       % image capture time interval
nstep     = cstep/tstep;
time      = starttime;  % current time
max_iter  = time_tol / cstep;      % max iteration
for qn = 1:nquad
    % Get start and stop position
    x0{qn}    = init_state(start{qn}, 0);
    xtraj{qn} = zeros(max_iter*nstep, length(x0{qn}));
    ttraj{qn} = zeros(max_iter*nstep, 1);
end

% Maximum position error of the quadrotor at goal
pos_tol  = 0.05; % m
% Maximum speed of the quadrotor at goal
vel_tol  = 0.05; % m/s

x = x0;        % state
realGoal = var.goal;
realGoal(:,3) = realGoal(:,3)*4;
%% ************************* RUN SIMULATION *************************
fprintf('Simulation Running....\n')
lineHandles = cell(nquad,1);
ellHandles = cell(nquad,1);
for iter = 1:max_iter
    timeint = time:tstep:time+cstep;
    tic;
    % Iterate over each quad
    for qn = 1:nquad
        % Initialize quad plot
        if iter == 1
            xreal = x0{qn};
            xreal(3)=xreal(3)*4;
            QP{qn} = QuadPlot(qn, xreal, 0.1, 0.04, quadcolors(qn,:), max_iter, h_3d);
            [desired_state,fret] = trajhandle(var, time, x0, qn);
            fprev = fret;
            des_real.pos = desired_state.pos;
            des_real.pos(3) = des_real.pos(3)*4;
            QP{qn}.UpdateQuadPlot(xreal, [des_real.pos; desired_state.vel], time);
            h_title = title(sprintf('iteration: %d, time: %4.2f', iter, time));
            hold on;
            plot3(realGoal(:,1),realGoal(:,2),realGoal(:,3),'go')
            
            realGoalOrd = realGoal(fret,:);
            lineHandles{qn} = line([xreal(1),realGoalOrd(qn,1)], ...
                [xreal(2),realGoalOrd(qn,2)],[xreal(3),realGoalOrd(qn,3)]);
            set(lineHandles{qn},'linestyle','--','color','k')
        
            xc = xreal(1);yc = xreal(2);zc = xreal(3);
        
            [xe,ye,ze] = ellipsoid(xc,yc,zc,hdist,hdist,hdist*4,30);
            ellHandles{qn} = surf(xe, ye, ze);
            set( ellHandles{qn}, 'FaceAlpha', 0.2)
            colormap summer
        end
        
        % Run simulation
        [tsave, xsave] = ode45(@(t,s) quadEOM_dcapt(t, s, qn, controlhandle, trajhandle, params, x, var), timeint, x{qn});
        x{qn} = xsave(end, :)';
        % Save to traj
        xtraj{qn}((iter-1)*nstep+1:iter*nstep,:) = xsave(1:end-1,:);
        ttraj{qn}((iter-1)*nstep+1:iter*nstep)   = tsave(1:end-1);
        
        % Update quad plot
        [desired_state, fret] = trajhandle(var, time + cstep, x, qn);
        
        xreal = x{qn};
        xreal(3) = xreal(3)*4;
        des_real = desired_state;
        des_real.pos(3) = des_real.pos(3)*4;
        realGoalOrd = realGoal(fret,:);
        QP{qn}.UpdateQuadPlot(xreal, [des_real.pos; des_real.vel], time + cstep);
        
        % plot leading lines
        set(lineHandles{qn},'XData',[xreal(1),realGoalOrd(qn,1)], ...
            'YData',[xreal(2),realGoalOrd(qn,2)], 'ZData',[xreal(3),realGoalOrd(qn,3)])
        
        xc = xreal(1);yc = xreal(2);zc = xreal(3);
        
        [xe,ye,ze] = ellipsoid(xc,yc,zc,hdist,hdist,hdist*4,30);
        set( ellHandles{qn}, 'XData', xe, 'YData', ye, 'ZData', ze )
        set( ellHandles{qn}, 'FaceAlpha', 0.2)
         colormap summer
                     shading flat


    end
    
    set(h_title, 'String', sprintf('iteration: %d, time: %4.2f', iter, time + cstep))
    time = time + cstep; % Update simulation time
    t = toc;
    
    % Pause to make real-time
    if (t < cstep)
        pause(cstep - t);
    end
    
    % Check termination criteria
    terminate_cond = terminate_check(x, time, stop, pos_tol, vel_tol, time_tol);
    if terminate_cond
        break
    end
    
    if any(fprev~=fret)
        colormap spring
        pause(0.1)
    else
        colormap summer
    end
    fprev = fret;
  
end
fprintf('Simulation Finished....\n')

%% ************************* POST PROCESSING *************************
% Truncate xtraj and ttraj
for qn = 1:nquad
    xtraj{qn} = xtraj{qn}(1:iter*nstep,:);
    ttraj{qn} = ttraj{qn}(1:iter*nstep);
end

% Plot the saved position and velocity of each robot
if vis
    for qn = 1:nquad
        % Truncate saved variables
        QP{qn}.TruncateHist();
        % Plot position for each quad
        h_pos{qn} = figure('Name', ['Quad ' num2str(qn) ' : position']);
        plot_state(h_pos{qn}, QP{qn}.state_hist(1:3,:), QP{qn}.time_hist, 'pos', 'vic');
        plot_state(h_pos{qn}, QP{qn}.state_des_hist(1:3,:), QP{qn}.time_hist, 'pos', 'des');
        % Plot velocity for each quad
        h_vel{qn} = figure('Name', ['Quad ' num2str(qn) ' : velocity']);
        plot_state(h_vel{qn}, QP{qn}.state_hist(4:6,:), QP{qn}.time_hist, 'vel', 'vic');
        plot_state(h_vel{qn}, QP{qn}.state_des_hist(4:6,:), QP{qn}.time_hist, 'vel', 'des');
    end
end

end
